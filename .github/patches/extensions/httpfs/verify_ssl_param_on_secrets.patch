diff --git a/src/create_secret_functions.cpp b/src/create_secret_functions.cpp
index be306433fb6..aa5c9b28f22 100644
--- a/src/create_secret_functions.cpp
+++ b/src/create_secret_functions.cpp
@@ -80,6 +80,12 @@ unique_ptr<BaseSecret> CreateS3SecretFunctions::CreateSecretFunctionInternal(Cli
 				                            lower_name, named_param.second.type().ToString());
 			}
 			secret->secret_map["use_ssl"] = Value::BOOLEAN(named_param.second.GetValue<bool>());
+		} else if (lower_name == "verify_ssl") {
+			if (named_param.second.type() != LogicalType::BOOLEAN) {
+				throw InvalidInputException("Invalid type past to secret option: '%s', found '%s', expected: 'BOOLEAN'",
+				                            lower_name, named_param.second.type().ToString());
+			}
+			secret->secret_map["verify_ssl"] = Value::BOOLEAN(named_param.second.GetValue<bool>());
 		} else if (lower_name == "kms_key_id") {
 			secret->secret_map["kms_key_id"] = named_param.second.ToString();
 		} else if (lower_name == "url_compatibility_mode") {
@@ -201,6 +207,7 @@ void CreateS3SecretFunctions::SetBaseNamedParams(CreateSecretFunction &function,
 	function.named_parameters["endpoint"] = LogicalType::VARCHAR;
 	function.named_parameters["url_style"] = LogicalType::VARCHAR;
 	function.named_parameters["use_ssl"] = LogicalType::BOOLEAN;
+	function.named_parameters["verify_ssl"] = LogicalType::BOOLEAN;
 	function.named_parameters["kms_key_id"] = LogicalType::VARCHAR;
 	function.named_parameters["url_compatibility_mode"] = LogicalType::BOOLEAN;
 	function.named_parameters["requester_pays"] = LogicalType::BOOLEAN;
diff --git a/src/httpfs.cpp b/src/httpfs.cpp
index b7252fde1a3..0e4e6399b70 100644
--- a/src/httpfs.cpp
+++ b/src/httpfs.cpp
@@ -97,6 +97,7 @@ unique_ptr<HTTPParams> HTTPFSUtil::InitializeParameters(optional_ptr<FileOpener>
 		result->http_proxy = host;
 		result->http_proxy_port = port;
 	}
+	result->override_verify_ssl = settings_reader->TryGetSecretKey<bool>("verify_ssl", result->verify_ssl);
 	settings_reader->TryGetSecretKey<string>("http_proxy_username", result->http_proxy_username);
 	settings_reader->TryGetSecretKey<string>("http_proxy_password", result->http_proxy_password);
 	settings_reader->TryGetSecretKey<string>("bearer_token", result->bearer_token);
diff --git a/src/httpfs_curl_client.cpp b/src/httpfs_curl_client.cpp
index 2771960628d..6c897816910 100644
--- a/src/httpfs_curl_client.cpp
+++ b/src/httpfs_curl_client.cpp
@@ -118,6 +118,9 @@ public:
 		curl_url_set(base_url, CURLUPART_URL, proto_host_port.c_str(), 0);
 		stored_bearer_token = "";
 		stored_cert_file_path = "";
+		if (StringUtil::StartsWith(proto_host_port, "https://")) {
+			https_connection = true;
+		}
 		Initialize(http_params);
 	}
 	void Initialize(HTTPParams &http_p) override {
@@ -159,7 +162,9 @@ public:
 			curl_easy_setopt(*curl, CURLOPT_FORBID_REUSE, 0L);
 		}
 
-		if (http_params.enable_curl_server_cert_verification) {
+		const bool use_ssl = http_params.override_verify_ssl ? http_params.verify_ssl : (https_connection && http_params.enable_curl_server_cert_verification);
+
+		if (use_ssl) {
 			curl_easy_setopt(*curl, CURLOPT_SSL_VERIFYPEER, 1L); // Verify the cert
 			curl_easy_setopt(*curl, CURLOPT_SSL_VERIFYHOST, 2L); // Verify that the cert matches the hostname
 		} else {
@@ -445,14 +450,7 @@ private:
 		auto status_code = HTTPStatusCode(request_info->response_code);
 		auto response = make_uniq<HTTPResponse>(status_code);
 		if (res != CURLcode::CURLE_OK) {
-			// __RESPONSE_STATUS__ is used for error propagation and debugging. It stores the full HTTP status trail,
-			// e.g. in cases of redirection failures, to help trace the sequence of HTTP statuses.
-			if (!request_info->header_collection.empty() &&
-			    request_info->header_collection.back().HasHeader("__RESPONSE_STATUS__")) {
-				response->request_error = request_info->header_collection.back().GetHeaderValue("__RESPONSE_STATUS__");
-			} else {
-				response->request_error = curl_easy_strerror(res);
-			}
+			response->request_error = curl_easy_strerror(res);
 			return response;
 		}
 		response->body = request_info->body;
@@ -478,6 +476,7 @@ private:
 	CURLU *base_url = nullptr;
 	string stored_bearer_token;
 	string stored_cert_file_path;
+	bool https_connection = false;
 
 	static std::mutex &GetRefLock() {
 		static std::mutex mtx;
diff --git a/src/httpfs_httplib_client.cpp b/src/httpfs_httplib_client.cpp
index 36593af7120..9012a598e63 100644
--- a/src/httpfs_httplib_client.cpp
+++ b/src/httpfs_httplib_client.cpp
@@ -9,6 +9,9 @@ class HTTPFSClient : public HTTPClient {
 public:
 	HTTPFSClient(HTTPFSParams &http_params, const string &proto_host_port) {
 		client = make_uniq<duckdb_httplib_openssl::Client>(proto_host_port);
+		if (StringUtil::StartsWith(proto_host_port, "https://")) {
+			https_connection = true;
+		}
 		Initialize(http_params);
 	}
 	void Initialize(HTTPParams &http_p) override {
@@ -18,7 +21,8 @@ public:
 		if (!http_params.ca_cert_file.empty()) {
 			client->set_ca_cert_path(http_params.ca_cert_file.c_str());
 		}
-		client->enable_server_certificate_verification(http_params.enable_server_cert_verification);
+		const bool use_ssl = http_params.override_verify_ssl ? http_params.verify_ssl : (https_connection && http_params.enable_server_cert_verification);
+		client->enable_server_certificate_verification(use_ssl);
 		client->set_write_timeout(http_params.timeout, http_params.timeout_usec);
 		client->set_read_timeout(http_params.timeout, http_params.timeout_usec);
 		client->set_connection_timeout(http_params.timeout, http_params.timeout_usec);
@@ -159,6 +163,7 @@ private:
 private:
 	unique_ptr<duckdb_httplib_openssl::Client> client;
 	optional_ptr<HTTPState> state;
+	bool https_connection = false;
 };
 
 unique_ptr<HTTPClient> HTTPFSUtil::InitializeClient(HTTPParams &http_params, const string &proto_host_port) {
