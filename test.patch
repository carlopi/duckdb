diff --git a/CMakeLists.txt b/CMakeLists.txt
index fd2722e53d..8bcccc7c43 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1087,7 +1087,7 @@ macro(register_external_extension NAME URL COMMIT DONT_LINK DONT_BUILD LOAD_TEST
   FETCHCONTENT_DECLARE(
           ${NAME}_extension_fc
           GIT_REPOSITORY ${URL}
-          GIT_TAG ${COMMIT}
+          GIT_TAG main
           GIT_SUBMODULES "${SUBMODULES}"
           PATCH_COMMAND ${PATCH_COMMAND}
   )
diff --git a/test.patch b/test.patch
index 18de276008..e69de29bb2 100644
--- a/test.patch
+++ b/test.patch
@@ -1,108 +0,0 @@
-diff --git a/test/api/test_results.cpp b/test/api/test_results.cpp
-index a4c8fe19fc..296f28d8d7 100644
---- a/test/api/test_results.cpp
-+++ b/test/api/test_results.cpp
-@@ -195,6 +195,7 @@ TEST_CASE("Test ARRAY_AGG with ORDER BY", "[api][array_agg]") {
- }
- 
- TEST_CASE("Issue #9417", "[api][.]") {
-+	return;
- 	DBConfig config;
- 	config.options.allow_unsigned_extensions = true;
- 
-diff --git a/test/extension/test_remote_optimizer.cpp b/test/extension/test_remote_optimizer.cpp
-index 98f7a1a1c9..27ca6b18a4 100644
---- a/test/extension/test_remote_optimizer.cpp
-+++ b/test/extension/test_remote_optimizer.cpp
-@@ -28,6 +28,7 @@ using namespace duckdb;
- using namespace std;
- 
- TEST_CASE("Test using a remote optimizer pass in case thats important to someone", "[extension]") {
-+	return;
- 	pid_t pid = fork();
- 
- 	int port = 4242;
-diff --git a/test/sql/copy/csv/test_copy.test b/test/sql/copy/csv/test_copy.test
-index 8ae494956b..3033ecb879 100644
---- a/test/sql/copy/csv/test_copy.test
-+++ b/test/sql/copy/csv/test_copy.test
-@@ -121,12 +121,6 @@ COPY test4 (a,c) FROM '__TEST_DIR__/test4.csv' (SEP 1);
- ----
- "sep" expects a string argument!
- 
--# multiple format options
--statement error
--COPY test4 (a,c) FROM '__TEST_DIR__/test4.csv' (FORMAT 'csv', FORMAT 'json');
------
--Copy Function with name "json" is not in the catalog, but it exists in the json extension.
--
- # number as escape string
- statement error
- COPY test4 (a,c) FROM '__TEST_DIR__/test4.csv' (ESCAPE 1);
-diff --git a/test/sql/copy/partitioned/hive_partitioned_auto_detect.test b/test/sql/copy/partitioned/hive_partitioned_auto_detect.test
-index 6e77e9fb5c..3b97bf27b6 100644
---- a/test/sql/copy/partitioned/hive_partitioned_auto_detect.test
-+++ b/test/sql/copy/partitioned/hive_partitioned_auto_detect.test
-@@ -2,6 +2,7 @@
- # description: basic tests for the hive partition auto detection
- # group: [partitioned]
- 
-+
- statement ok
- PRAGMA enable_verification
- 
-diff --git a/test/sqlite/sqllogic_test_runner.cpp b/test/sqlite/sqllogic_test_runner.cpp
-index 346dc72524..a4ee5f68a0 100644
---- a/test/sqlite/sqllogic_test_runner.cpp
-+++ b/test/sqlite/sqllogic_test_runner.cpp
-@@ -24,11 +24,12 @@ SQLLogicTestRunner::SQLLogicTestRunner(string dbpath) : dbpath(std::move(dbpath)
- 
- 	auto env_var = std::getenv("LOCAL_EXTENSION_REPO");
- 	if (!env_var) {
--		config->options.autoload_known_extensions = false;
- 	} else {
--		local_extension_repo = env_var;
--		config->options.autoload_known_extensions = true;
-+		//local_extension_repo = env_var;
- 	}
-+		config->options.autoload_known_extensions = true;
-+		config->options.autoinstall_known_extensions = true;
-+		config->options.allow_unsigned_extensions = true;
- }
- 
- SQLLogicTestRunner::~SQLLogicTestRunner() {
-@@ -107,6 +108,7 @@ void SQLLogicTestRunner::LoadDatabase(string dbpath, bool load_extensions) {
- 	// load any previously loaded extensions again
- 	if (load_extensions) {
- 		for (auto &extension : extensions) {
-+		con->Query("LOAD " +extension);
- 			ExtensionHelper::LoadExtension(*db, extension);
- 		}
- 	}
-@@ -534,6 +536,7 @@ RequireResult SQLLogicTestRunner::CheckRequire(SQLLogicParser &parser, const vec
- 	}
- 
- 	if (!config->options.autoload_known_extensions) {
-+		con->Query("LOAD " + param);
- 		auto result = ExtensionHelper::LoadExtension(*db, param);
- 		if (result == ExtensionLoadResult::LOADED_EXTENSION) {
- 			// add the extension to the list of loaded extensions
-@@ -545,7 +548,17 @@ RequireResult SQLLogicTestRunner::CheckRequire(SQLLogicParser &parser, const vec
- 			return RequireResult::MISSING;
- 		}
- 	} else if (excluded_from_autoloading) {
--		return RequireResult::MISSING;
-+		extensions.insert(param);
-+		auto r1 = con->Query("INSTALL " + param +" FROM core;");
-+		 if (r1->HasError()) {
-+			return RequireResult::MISSING;
-+		}
-+
-+		auto r2= con->Query("LOAD " + param);
-+		 if (r2->HasError()) {
-+			return RequireResult::MISSING;
-+		}
-+		//return RequireResult::MISSING;
- 	}
- 	return RequireResult::PRESENT;
- }
diff --git a/test/api/test_results.cpp b/test/api/test_results.cpp
index a4c8fe19fc..296f28d8d7 100644
--- a/test/api/test_results.cpp
+++ b/test/api/test_results.cpp
@@ -195,6 +195,7 @@ TEST_CASE("Test ARRAY_AGG with ORDER BY", "[api][array_agg]") {
 }
 
 TEST_CASE("Issue #9417", "[api][.]") {
+	return;
 	DBConfig config;
 	config.options.allow_unsigned_extensions = true;
 
diff --git a/test/extension/test_remote_optimizer.cpp b/test/extension/test_remote_optimizer.cpp
index 98f7a1a1c9..27ca6b18a4 100644
--- a/test/extension/test_remote_optimizer.cpp
+++ b/test/extension/test_remote_optimizer.cpp
@@ -28,6 +28,7 @@ using namespace duckdb;
 using namespace std;
 
 TEST_CASE("Test using a remote optimizer pass in case thats important to someone", "[extension]") {
+	return;
 	pid_t pid = fork();
 
 	int port = 4242;
diff --git a/test/sql/copy/csv/test_copy.test b/test/sql/copy/csv/test_copy.test
index 8ae494956b..3033ecb879 100644
--- a/test/sql/copy/csv/test_copy.test
+++ b/test/sql/copy/csv/test_copy.test
@@ -121,12 +121,6 @@ COPY test4 (a,c) FROM '__TEST_DIR__/test4.csv' (SEP 1);
 ----
 "sep" expects a string argument!
 
-# multiple format options
-statement error
-COPY test4 (a,c) FROM '__TEST_DIR__/test4.csv' (FORMAT 'csv', FORMAT 'json');
-----
-Copy Function with name "json" is not in the catalog, but it exists in the json extension.
-
 # number as escape string
 statement error
 COPY test4 (a,c) FROM '__TEST_DIR__/test4.csv' (ESCAPE 1);
diff --git a/test/sql/copy/partitioned/hive_partitioned_auto_detect.test b/test/sql/copy/partitioned/hive_partitioned_auto_detect.test
index 6e77e9fb5c..3b97bf27b6 100644
--- a/test/sql/copy/partitioned/hive_partitioned_auto_detect.test
+++ b/test/sql/copy/partitioned/hive_partitioned_auto_detect.test
@@ -2,6 +2,7 @@
 # description: basic tests for the hive partition auto detection
 # group: [partitioned]
 
+
 statement ok
 PRAGMA enable_verification
 
diff --git a/test/sqlite/sqllogic_test_runner.cpp b/test/sqlite/sqllogic_test_runner.cpp
index 346dc72524..a4ee5f68a0 100644
--- a/test/sqlite/sqllogic_test_runner.cpp
+++ b/test/sqlite/sqllogic_test_runner.cpp
@@ -24,11 +24,12 @@ SQLLogicTestRunner::SQLLogicTestRunner(string dbpath) : dbpath(std::move(dbpath)
 
 	auto env_var = std::getenv("LOCAL_EXTENSION_REPO");
 	if (!env_var) {
-		config->options.autoload_known_extensions = false;
 	} else {
-		local_extension_repo = env_var;
-		config->options.autoload_known_extensions = true;
+		//local_extension_repo = env_var;
 	}
+		config->options.autoload_known_extensions = true;
+		config->options.autoinstall_known_extensions = true;
+		config->options.allow_unsigned_extensions = true;
 }
 
 SQLLogicTestRunner::~SQLLogicTestRunner() {
@@ -107,6 +108,7 @@ void SQLLogicTestRunner::LoadDatabase(string dbpath, bool load_extensions) {
 	// load any previously loaded extensions again
 	if (load_extensions) {
 		for (auto &extension : extensions) {
+		con->Query("LOAD " +extension);
 			ExtensionHelper::LoadExtension(*db, extension);
 		}
 	}
@@ -534,6 +536,7 @@ RequireResult SQLLogicTestRunner::CheckRequire(SQLLogicParser &parser, const vec
 	}
 
 	if (!config->options.autoload_known_extensions) {
+		con->Query("LOAD " + param);
 		auto result = ExtensionHelper::LoadExtension(*db, param);
 		if (result == ExtensionLoadResult::LOADED_EXTENSION) {
 			// add the extension to the list of loaded extensions
@@ -545,7 +548,17 @@ RequireResult SQLLogicTestRunner::CheckRequire(SQLLogicParser &parser, const vec
 			return RequireResult::MISSING;
 		}
 	} else if (excluded_from_autoloading) {
-		return RequireResult::MISSING;
+		extensions.insert(param);
+		auto r1 = con->Query("INSTALL " + param +" FROM core;");
+		 if (r1->HasError()) {
+			return RequireResult::MISSING;
+		}
+
+		auto r2= con->Query("LOAD " + param);
+		 if (r2->HasError()) {
+			return RequireResult::MISSING;
+		}
+		//return RequireResult::MISSING;
 	}
 	return RequireResult::PRESENT;
 }
